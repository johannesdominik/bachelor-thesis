\chapter{Design and Architecture}
\label{cha:DesignArchitecture}

This chapter builds on top of the concepts and use cases of the previous chapters and lays out the architecture and design of a typical decentralized application by using a more practical approach. After a short introduction into the used technologies there will be a detailed view on each important part of a modern decentralized web application. To keep this chapter more concise, only selected code snippets will be shown to describe certain aspects. However, the entire code base of the working application can be found on Github \cite{CherryPool}.

\section{Technology Stack}
\subsection{Solidity}
The main components of decentralized web applications are Smart Contracts. Smart Contracts can be written in a few different programming languages such as LLL, Serpent, Solidity, Vyper and Bamboo. Solidity is by far the most popular and currently the de-facto standard in writing Smart Contracts \cite{AntonopoulosWood2018}. Solidity is statically typed, has a JavaScript-like syntax and supports various popular programming concepts such as libraries and inheritance \cite{SolidityDocumentation}. Because there are no classes in Solidity, it is considered not as an object-oriented but as a contract-oriented language \cite{Solidity}.

\subsection{Truffle}
Truffle is a development environment which helps to develop decentralized applications on the Ethereum Virtual Machine \cite{Truffle}. It handles all the difficult parts starting from Smart Contract compilation, testing, linking, deployment and continuous integration. When developing more than just some simple Smart Contracts, Truffle is an important tool to save a lot of time.

\subsection{Ganache}
Because testing a decentralized application on the main Ethereum network would not be a good idea (and is expensive too), some sort of testing blockchain is needed. Ganache is a local blockchain for developers which provides everything to test a decentralized applications on the local machine \cite{Ganache}. It offers accounts with fake ether and works really well with Truffle, which is built by the same developers.

\subsection{Web3}
In order to link Smart Contracts to a graphical user interface such as a web client application, web3.js comes into play. It is a JavaScript library and provides all the necessary APIs in order to connect a blockchain backend to a web frontend \cite{Web3}. It also manages connections to specific wallet providers such as MetaMask.

\subsection{Mocha \& Chai}
Testing plays in blockchain development an even bigger role than in software development in general, because deployed Smart Contracts are immutable and bugs literally cost money. A flawed function with causes an endless loop whould burn the entire gas that was available for that function call without doing anything useful. Mocha is a JavaScript testing framework which makes it possible to test the functionality of each Smart Contract in a structured and automated way \cite{Mocha}. Together with the assertion library Chai \cite{Chai} and the integration into Truffle, Mocha releases its full potential as a fully fledged blockchain testing environment.

\subsection{React}
What would be the best Smart Contract without a graphical user interfaces which gives people the opportunity to interact with the blockchain in an easy and intuitive way. React is a JavaScript library for building user interfaces for the web and by far the most popular web framework out there \cite{React}. React is super fast because it uses a virtual DOM and provides the user a modern and intuitive experience.

\subsection{TypeScript}
While other frontend frameworks such as Angular come with TypeScript out of the box, you have to add additional dependencies in React yourself. When it comes to larger projects or whenever bugs could become expensive, it is a good idea to introduce some kind of type checking in JavaScript. TypeScript is a superset of JavaScript and helps to detect errors before they occur at runtime \cite{TypeScript}. In financial applications like this, there is usually an even higher focus on reliable, bug-free code.

\section{The SafeMath Library}
Arithmetic operations in Solidity wrap on overflow. This can lead to bugs, because most programmers assume, that it would raise an exception when an overflow occurs, as it is done in other high level programming languages. By introducing the library \texttt{SafeMath}, an entire class of bugs is being eliminated so it should be used everywhere possible.

\begin{program}
\caption{The SafeMath library.}
\label{prog:SafeMath}
\begin{GenericCode}
library SafeMath {
  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {
    assert(_b <= _a);
    return _a - _b;
  }

  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {
    uint256 c = _a + _b;
    assert(c >= _a);
    return c;
  }
}
\end{GenericCode}
\end{program}

\section{The ERC20 Token Standard}
\label{sec:ERC20}
The ERC20 standard makes it possible to build standardized tokens on the Ethereum protocol which can be integrated into the existing ecosystem \cite{ERC20}. This is achieved through a common interface each token needs to implement. The standard was initially introduced in 2015 as an Ethereum Request for Comments (ERC). It received its name due to the automatic issue assignment on Github, which had the issue number 20 \cite{AntonopoulosWood2018} \cite{BadrHorrocksWu2018}.

\subsection{Example Implementation}
The function \texttt{totalSupply} returns the maximum amount available of this token in \textit{wei}, the smallest unit possible. The supply can be either static or dynamic. In this case, it is static assigned through the constructor when the smart Contract is created. The return type is a 256 bit unsigned integer which is the most common data type in Solidity.

\begin{GenericCode}
 uint256 private _totalSupply;
  
 function totalSupply() public view returns (uint256) {
   return _totalSupply;
 }	
\end{GenericCode}

Each token is responsible to keep track of all addresses holding that token. This can be stored using the data type \texttt{mapping} which is a key value pair of addresses and token amounts. The function \texttt{balanceOf} returns the token balance for a specific address.

\begin{GenericCode}
 mapping(address => uint256) private balances;
  
 function balanceOf(address _owner) public view returns (uint256 balance) {
   return balances[_owner];
 }
\end{GenericCode}

The functionality of sending tokens to a specific address is implemented in the \texttt{transfer} function. It takes an address and an amount as parameters and returns a boolean if the transaction was successful. The \texttt{require} function checks for a specific condition to be true. If this is not the case, the function will be reverted and all the gas goes back to the sender, which can be evaluated in Solidity using \texttt{msg.sender}. In order to prevent over- or underflow errors when performing additions and subtractions, a small library \texttt{SafeMath} \ref{prog:SafeMath} is being utilized. If everything worked well, the \texttt{Transfer} event will be emitted.

\begin{GenericCode}
function transfer(address _to, uint256 _value) public returns (bool success) {
  require(_value <= balances[msg.sender]);
  balances[msg.sender] = balances[msg.sender].sub(_value);
  balances[_to] = balances[_to].add(_value);
  emit Transfer(msg.sender, _to, _value);
  return true;
}
\end{GenericCode}

The function \texttt{transferFrom} is very similar to \texttt{transfer} with the only difference that the caller is not the one who sends the tokens. This is usually not a physical person but rather a Smart Contract of a decentralized application. Tokens can be sent only on behalf of someone else if the sender accepts the amount first. All funds that are already released for transactions are stored in another mapping specifying for each address which addresses are enabled to send what amount.

\begin{GenericCode}
mapping(address => mapping(address => uint256)) private allowed;

function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
  require(_value <= balances[_from]);
  require(_value <= allowed[_from][msg.sender]);
  balances[_from] = balances[_from].sub(_value);
  allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
  balances[_to] = balances[_to].add(_value);
  emit Transfer(_from, _to, _value);
  return true;
}
\end{GenericCode}

If the caller is not the sender of a transaction, funds need to be approved first. That is exactly what the function \texttt{approve} does. It authorizes the spender to spend a specific amount of the tokens of the address which called the function. Old funds that are already authorized will not be accumulated but overwritten. This makes it possible to revert an approval by calling the \texttt{approve} function another time with the value of zero. This function emits the \texttt{Approval} event.
\begin{GenericCode}
function approve(address _spender, uint256 _value) public returns (bool success) {
  allowed[msg.sender][_spender] = _value;
  emit Approval(msg.sender, _spender, _value);
  return true;
}
\end{GenericCode}

Because the data structure holding the allowed funds is usually private, a public interface is needed to find out how much remaining tokens can be spent on behalf of someone else. The function \texttt{allowance} takes two parameters and returns the amount of tokens that the spender is authorized to spend from the owner's address.
\begin{GenericCode}
function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
  return allowed[_owner][_spender];
}
\end{GenericCode}

The events \texttt{Transfer} and \texttt{Approval} play an important role in the interface of an ERC20 token. The \texttt{Transfer} event is emitted every time when a transaction is about to be executed. The \texttt{Approval} event is being called every time some tokens need to be approved. Both events trigger some sort of action in the linked wallet application of the user. For example, the browser wallet MetaMask opens a popup window asking the user for confirmation, once an event is emitted. 
\begin{GenericCode}
event Transfer(address indexed _from, address indexed _to, uint256 _value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);
\end{GenericCode}

\section{Liquidity Pool Implementation}
There are a few different approaches on how to implement a lending functionality. One possibility would be the utilization of collateral like it is done by Maker\cite{MakerDAO2021}. However, this section will describe how to implement a lending application using liquidity pools as it builds the foundation for a decentralized exchange such as Uniswap\cite{Uniswap2020}.

As described in section \ref{subsec:liquiditypools}, liquidity pools need to have a pair of cryptocurrencies or tokens. As we are building on top of the Ethereum network, we are limited to Ether and Ethereum tokens. In this example, the liquidity pool holds Ether and an ERC20 token called CherryToken, as implemented in section \ref{sec:ERC20}. Besides the token reference \texttt{cherryToken} and the exchange reference \texttt{cherrySwap}, the smart contract needs to keep track of the curren pool balance, its collected fees by the exchange and the balances each liquidity miner holds. The mapping \texttt{unresolvedEth} is needed to manage Ether that is sent to the contract without referencing a specific swap transaction.
\begin{GenericCode}
string public name = "CherryLiquidity";
address public owner;
CherryToken public cherryToken;
CherrySwap public cherrySwap;
uint256 private ethBalance;
uint256 private ctnBalance;
uint256 private collectedFees = 0;
mapping(address => uint256) private balancesInEth;
mapping(address => uint256) private balancesInCtn;
mapping(address => uint256) private unresolvedEth;
\end{GenericCode}

The constructor initializes the smart contract, sets the contract references and seeds the pool with an initial amount. The getter functions \texttt{getEthBalance}, \texttt{getCtnBalance} and \texttt{getCollectedFees} provide the frontend with necessary information to implement a good user experience and to keep as much calculation off-chain.
\begin{GenericCode}
constructor(CherryToken _cherryToken, CherrySwap _cherrySwap, uint256 _initialEthSupply, uint256 _initialCtnSupply) public {
  cherryToken = _cherryToken;
  cherrySwap = _cherrySwap;
  ethBalance = _initialEthSupply;
  ctnBalance = _initialCtnSupply;
  cherryToken.transferFrom(msg.sender, address(this), _initialCtnSupply);
  owner = msg.sender;
}

function getEthBalance() public view returns (uint256 balance) {
  return address(this).balance;
}

function getCtnBalance() public view returns (uint256 balance) {
  return cherryToken.balanceOf(address(this)) - collectedFees;
}

function getCollectedFees() public view returns (uint256 fees) {
  return collectedFees;
}
\end{GenericCode}

Adding liquidity works a little bit different for Ether and an ERC20 token, as Ether is a fundamental feature of Solidity and an ERC20 token is managed by the smart contract itself. At first, Ether needs to be sent to \texttt{addEthLiquidity}. As it is a payable function, it is able to receive funds. They are owned by the smart contract and are mapped to the user through his address, which is stored in \texttt{msg.sender}. Secondly, the function \texttt{addLiquidity} needs to be called to complete the pool deposit. After a few integrity checks, the unresolved Ether will be reduced, the tokens transferred and the pool balances updated.
\begin{GenericCode}
function addEthLiquidity() payable {
  require(msg.value > 0, "ETH amount cannot be 0");
  unresolvedEth[msg.sender] = unresolvedEth[msg.sender] + msg.value;
}

function addLiquidity(uint256 _ethAmount, uint256 _ctnAmount) public {
  require(unresolvedEth[msg.sender] >= _ethAmount, "ETH not sent yet");
  require(_ctnAmount > 0, "CTN amount cannot be 0");
  require(cherryToken.balanceOf(msg.sender) > _ctnAmount, "not enough CTN funds");
  unresolvedEth[msg.sender] = unresolvedEth[msg.sender] - _ethAmount;
  cherryToken.transferFrom(msg.sender, address(this), _ctnAmount);
  balancesInEth[msg.sender] = balancesInEth[msg.sender] + _ethAmount;
  balancesInCtn[msg.sender] = balancesInCtn[msg.sender] + _ctnAmount;
}	
\end{GenericCode}

Removing liquidity from the pool means withdrawing the lended funds and receiving an additional reward proportional to the pool share. As the reward calculation is quite computational intensive and Soldity is not good at managing divisions and percentages, the reward will be computed off-chain.
\begin{GenericCode}
function removeLiquidity(uint256 _ethAmount, uint256 _ctnAmount, uint256 reward) public {
  require(_ethAmount > 0, "eth amount cannot be 0");
  require(_ctnAmount > 0, "ctn amount cannot be 0");
  require(getEthBalance() >= _ethAmount, "not enough ETH in pool");
  require(getCtnBalance() >= _ctnAmount, "not enough CTN in pool");
  require(balancesInEth[msg.sender] > _ethAmount, "not enough ETH deposited");
  require(balancesInCtn[msg.sender] > _ctnAmount, "not enough CTN deposited");
  require(collectedFees >= reward, "invalid reward");
  uint256 ctnPayout = _ctnAmount + reward;
  cherryToken.transferFrom(address(this), msg.sender, ctnPayout);
  msg.sender.transfer(_ethAmount);
  balancesInEth[msg.sender] = balancesInEth[msg.sender] - _ethAmount;
  balancesInCtn[msg.sender] = balancesInCtn[msg.sender] - _ctnAmount;
}	
\end{GenericCode}

The functions \texttt{processEthToCtn} and \texttt{processCtnToEth} are being called by the exchange in order to withdraw the needed funds and deduct the fees. To make sure only the exchange can call this function, the address of the recipient will be checked at the beginning of each function.
\begin{GenericCode}
function processEthToCtn(address recipient, uint256 ctnAmount, uint256 fees) public  {
  require(msg.sender == address(cherrySwap), "address not authorized");
  addFees(fees);
  cherryToken.transfer(recipient, ctnAmount);
}

function processCtnToEth(address recipient, uint256 ethAmount, uint256 fees) public {
  require(msg.sender == address(cherrySwap), "address not authorized");
  addFees(fees);
  recipient.transfer(ethAmount);
}

function addFees(uint256 _amount) private {
  collectedFees = collectedFees + _amount;
}	
\end{GenericCode}

\section{Exchange Implementation}
--- 1.25 page ---

\section{Testing Smart Contracts}
--- 1.25 page ---

\section{Connecting Smart Contracts to Web Applications}
--- 1 page ---

\section{Smart Contract Deployment}
--- 0.5 page ---
